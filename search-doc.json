[{"title":"âŒ Erreur","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Error","content":"âŒ Erreur On dispose d'un type d'erreur propre pour les erreurs de dÃ©codage: pub enum ErrorKind { General, Impossible, NoMatrix, FieldZoneDecoder, Decoder, Signing } pub struct Error{ pub kind: ErrorKind, pub value: String } Copy Nous avons Ã  peu prÃ¨s un type par module, et on ajoute une description dÃ©taillÃ© dans le champ value.","keywords":""},{"title":"ğŸ§° FieldZoneDecoder","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Message","content":"ğŸ§° FieldZoneDecoder Un message est constituÃ© dâ€™une sÃ©quence de blocs de donnÃ©es. Chaque bloc de donnÃ©es est constituÃ© des Ã©lÃ©ments suivants : D'un Identifiant de DonnÃ©e (ID) sur deux caractÃ¨res.De la DonnÃ©e (D).Dâ€™un Ã©ventuel caractÃ¨re de fin de donnÃ©e GS ou de troncature de donnÃ©e RS. Selon lâ€™ID, la DonnÃ©e peut-Ãªtre : De longueur fixeDe longueur variable, avec une borne supÃ©rieureDe longueur variable avec des bornes infÃ©rieure et supÃ©rieureDe longueur variable non bornÃ©e On rÃ©cupÃ¨re ces informations Ã  l'aide du FieldSpecificationStore FieldSpecificationsStore::get(&id) Copy On cherche ensuite RS ou GS dans la zone [B_inf, B_sup], et on consomme la sous-chaine. info C'est aussi ici que l'on ajoute les informations de troncature A la fin, on retourne une FieldZone complÃ¨te, mais pas validÃ©.","keywords":""},{"title":"ğŸ© En-tÃªtes","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Entete","content":"ğŸ© En-tÃªtes Nous avons crÃ©Ã© la structure correspondante Headers : pub struct Headers { pub marqueur : String, pub version : String, pub identifiant_de_ac : String, pub identifiant_du_certificat : String, pub date_emission : String, pub date_signature: String, pub type_document: String, pub perimetre : Option<String>, // version \"03\" pub pays_emetteur : Option<String>, // version \"04\" } Copy tip On utilise le type Option de rust, permettant d'ajouter une valeur par la suite, uniquement pour les documents ayant une version supÃ©rieure ou Ã©gale Ã  2 Donc au dÃ©but, on a la fonction initialiser, qui parse le code et remplit chaque champs de la structure. Ensuite, en fonction de la version de l'en-tÃªte du 2D-Doc Ã  decrypter on remplit soit le champs perimetre, soit le champs pays-emetteur grÃ¢ce Ã  la fonction remplir cas particuliers. let mut entete = Headers ::initialiser(str); entete.remplir_cas_particuliers(str); Copy","keywords":""},{"title":"ğŸ— Builder","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Builder","content":"ğŸ— Builder On utiliser un Builder pour composer notre structure DocumentDecoded, il est en charge des fonctions suivantes: HeadersFieldZoneValidation de document (Validator)Validation de signature (Signer) let (headers, headers_size) = Headers::new(str); let document_raw = DocumentRaw::new(str, headers_size)?; let mut document_decoded = DocumentDecodedBuilder::new() .add_headers(headers) .decode_message(&document_raw.message)? .collect().to_error(ErrorKind::Decoder, String::from(\"Error decoding\"))?; let signing = Signing::verify_signature(&document_raw, &document_decoded)?; let validity = Validity::validate(&mut document_decoded); Ok(Document { raw: document_raw, decoded: document_decoded, signing, validity }) Copy","keywords":""},{"title":"ğŸ”‘ Signer","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Signer","content":"ğŸ”‘ Signer Pour tester la signature, on appele simplement la fonction check_signature du module externe dÃ©diÃ© Signing{ valid: is_valid } Copy","keywords":""},{"title":"âœ” Validator","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Validator","content":"âœ” Validator La validation effective d'un document s'effectue aprÃ¨s son dÃ©codage, a l'aide des elements de Specification (voir ici) On valide donc chaque DI (la FieldZone) ainsi que le Document lui mÃªme Validity{ valid: fz_valid && doc_valid } Copy","keywords":""},{"title":"ğŸª SpecificationStore","type":0,"sectionRef":"#","url":"docs/Implementation/Specifications/SpecificationStore","content":"","keywords":""},{"title":"ğŸ’¡ IdÃ©eâ€‹","type":1,"pageTitle":"ğŸª SpecificationStore","url":"docs/Implementation/Specifications/SpecificationStore#-idÃ©e","content":"Nous avons besoin des spÃ©cifications Ã  de nombreux moments de la procÃ©dure de dÃ©codage. Nous avons donc dÃ©cidÃ© d'implÃ©menter nos spÃ©cifications Ã  travers une structure suivant un pattern Singleton: Une hashmap est chargÃ©e durant l'initialisation, et gardÃ©e en mÃ©moire durant la vie du programme. Ces structures sont FieldSpecificationStore et DocumentSpecificationStore, et implÃ©mente le trait SpecificationStore  "},{"title":"ğŸ”§ JSON -> HashMapâ€‹","type":1,"pageTitle":"ğŸª SpecificationStore","url":"docs/Implementation/Specifications/SpecificationStore#-json---hashmap","content":"C'est notre toolchain rust (build.rs) qui transforme le JSON en code rust, corps de l'implÃ©mentation fill de SpecificationStore. "},{"title":"ğŸ Executionâ€‹","type":1,"pageTitle":"ğŸª SpecificationStore","url":"docs/Implementation/Specifications/SpecificationStore#-execution","content":"Lors de l'exÃ©cution du programme, c'est une crate rust (lazy_static) qui crÃ©e une rÃ©fÃ©rence accessible de maniÃ¨re globale. On a donc bien une hashmap statique ! "},{"title":"ğŸ’» Bindgen","type":0,"sectionRef":"#","url":"docs/Modules_externes/bindgen","content":"","keywords":""},{"title":"ğŸ“ Principeâ€‹","type":1,"pageTitle":"ğŸ’» Bindgen","url":"docs/Modules_externes/bindgen#-principe","content":"Permet de transformer des .h en interface .rs Cargo recupÃ¨re les sources, compile & install le binary /home/foo/.cargo/bin/bindgen apt install llvm-dev libclang-dev clang cargo install bindgen "},{"title":"ğŸ”§ Utilisationâ€‹","type":1,"pageTitle":"ğŸ’» Bindgen","url":"docs/Modules_externes/bindgen#-utilisation","content":"bindgen --allowlist-function 'dmtx.' --allowlist-type 'Dmtx.' --allowlist-var 'Dmtx.*' dmtx.h -o test.rs --no-layout-tests On prÃ©cise a rust de ne pas afficher les erreurs de style de code #![allow(non_camel_case_types)] #![allow(non_snake_case)] #![allow(deref_nullptr)] #![allow(non_upper_case_globals)] #![allow(dead_code)] Copy On obtient finalement un fichier FFI pour rust, chez nous /src/libdmtx/libdmtx_sys.rs "},{"title":"ğŸ¥‡ Fonctions de validation","type":0,"sectionRef":"#","url":"docs/Implementation/Specifications/Fonctions_validations","content":"","keywords":""},{"title":"ğŸ“ Principeâ€‹","type":1,"pageTitle":"ğŸ¥‡ Fonctions de validation","url":"docs/Implementation/Specifications/Fonctions_validations#-principe","content":"Pour vÃ©rifier la validitÃ© d'un document, on doit tester deux principaux points : Si il contient bien tous les DI obligatoires.Si la valeur des DI est conforme a leurs spÃ©cifications. Pour cela, on utilise deux mÃ©thodes de validation pour chaque point: Une mÃ©thode ensembliste: On va tester si les valeurs sont prÃ©sentes dans un ensemble prÃ©dÃ©terminÃ©Une mÃ©thode via fonction On va appliquer une fonction de validation sur les valeurs On a donc 4 fichiers liÃ© Ã  la validation. Les appels Ã  ces fonctions de validation sont inclus dans les Specifications. "},{"title":"ğŸ”§ Exemple avec FieldSpecification:â€‹","type":1,"pageTitle":"ğŸ¥‡ Fonctions de validation","url":"docs/Implementation/Specifications/Fonctions_validations#-exemple-avec-fieldspecification","content":" pub struct FieldSpecification{ pub id: &'static str, pub nom: &'static str, pub taille_min: i16, pub taille_max: i16, pub type_identifiant: &'static str, pub description: &'static str, pub validate: ValidatingConditionField, } pub enum ValidatingConditionField { FUNCTION(Vec<fn(&str, bool) -> Result<(), Error>>), SET(Vec<fn(&char, bool) -> Result<(), Error>>) } Copy et on a une mÃ©thode de FieldSpecification qui permet d'effectuer la validation: pub fn validate(&self, value: &str, truncated: bool) -> Result<(), Vec<Error>> Copy info On peut mÃªme tester plusieurs fonction sur un mÃªme champ, c'est-Ã -dire tester plusieurs conditions. "},{"title":"âŒ Erreursâ€‹","type":1,"pageTitle":"ğŸ¥‡ Fonctions de validation","url":"docs/Implementation/Specifications/Fonctions_validations#-erreurs","content":"De plus, on a crÃ©e un type d'erreur spÃ©cifique Ã  la validation des documents: pub struct Error{ pub kind: ErrorKind, pub value: String } pub enum ErrorKind { General, NotInSet, FailedFunction, SizeNotRespected, InvalidCaracter, DocumentFields } Copy "},{"title":"ğŸ”¨ ImplÃ©mentation","type":0,"sectionRef":"#","url":"docs/Modules_externes/securite/securite_impl","content":"ğŸ”¨ ImplÃ©mentation L'implÃ©mentation de notre module sÃ©curitÃ© Ã  Ã©tÃ© pensÃ©e pour Ãªtre interchangeable (pour une utilisation de openSSL par ex.) On a donc une interface unique, sous la forme d'une fonction, qui valide ou non un document: pub fn check_signature(data_zone: &str, signature: &str, authority_id: &str, certificate_id: &str) -> Result<bool, String> Copy La fonction renvoie donc un boolÃ©en correspondant Ã  la validitÃ© du document, ou un message d'erreur. info La vÃ©rification nÃ©cessitant l'accÃ¨s aux Annuaire de certificats, notre implÃ©mentation actuelle nÃ©cessite une connexion internet. Une Ã©volution possible est l'utilisation d'un \"cache\" de certificats, pour une utilisation hors ligne.","keywords":""},{"title":"ğŸ§° Utilisation de libDMTX en rust","type":0,"sectionRef":"#","url":"docs/Modules_externes/libDMTX_rust","content":"","keywords":""},{"title":"ğŸ”¨ Librairieâ€‹","type":1,"pageTitle":"ğŸ§° Utilisation de libDMTX en rust","url":"docs/Modules_externes/libDMTX_rust#-librairie","content":"Pour pouvoir utiliser la librairie: mod dmtx; //Pour que le compileur ajoute -ldmtx #[link(name = \"dmtx\")] extern {} Copy On obtient des signatures rust de cette forme: pub unsafe fn dmtxImageCreate(pxl: *mut std::os::raw::c_uchar, width: std::os::raw::c_int, height: std::os::raw::c_int, pack: std::os::raw::c_int) -> *mut DmtxImage Copy "},{"title":"ğŸŒ® Wrapperâ€‹","type":1,"pageTitle":"ğŸ§° Utilisation de libDMTX en rust","url":"docs/Modules_externes/libDMTX_rust#-wrapper","content":"Attention, les signatures et les types sont au format c (avec pointeurs...) On devrait donc faire une \"safe interface\", suivant les bonnes pratiques rust. Par simplicitÃ©, on a choisit d'utiliser libDMTX de faÃ§on brut, en gardant tout le code \"unsafe\" dans une seule fonction. (/src/libdmtx/mod.rs) "},{"title":"ğŸ”§ Utilisationâ€‹","type":1,"pageTitle":"ğŸ§° Utilisation de libDMTX en rust","url":"docs/Modules_externes/libDMTX_rust#-utilisation","content":"pub fn dmtx_read(pxl: &[u8], width: u32, height: u32, pack: DmtxPackOrder) -> Vec<u8> Copy Notre interface rust pour libdmtx prends donc en entrÃ©e un vecteur plat de pixels, la largeur et hauteur de l'image, ainsi que son packOrder. On retourne un vecteur rust contenant les donnÃ©es du Datamatrix , ou un vecteur vide en cas d'abscence de matrice (on donne 1s a libdmtx pour trouver la matrice) "},{"title":"ğŸ“ˆ AmÃ©liorations","type":0,"sectionRef":"#","url":"docs/project/Ameliorations_possibles","content":"ğŸ“ˆ AmÃ©liorations Sont ici listÃ© les amÃ©liorations possibles: CrÃ©er une ffi propre pour libDMTX, safeFaire une implÃ©mentation via OpenSSL de security","keywords":""},{"title":"ğŸ“ Serialiser","type":0,"sectionRef":"#","url":"docs/Modules_externes/serialiser","content":"","keywords":""},{"title":"ğŸ“ Interfaceâ€‹","type":1,"pageTitle":"ğŸ“ Serialiser","url":"docs/Modules_externes/serialiser#-interface","content":"On propose l'interface suivante pour sÃ©rialiser un Document ou une Erreur: pub fn serialize(doc: Result<Document, ErrorDocument>) -> String Chacun est libre d'implÃ©menter le \"sÃ©rialiseur\" qu'il prÃ©fÃ¨re. "},{"title":"ğŸ§°ImplÃ©mentationâ€‹","type":1,"pageTitle":"ğŸ“ Serialiser","url":"docs/Modules_externes/serialiser#implÃ©mentation","content":"Nous avons implÃ©mentÃ© une serialisation vers JSON. En effet, ce format de donnÃ©es est compris par la plupart des plateformes et permet donc une grande interopÃ©rabilitÃ© Nous avons utilisÃ© la crate rust serde, qui permet de sÃ©rialiser vers de nombreux formats. On a une \"vue\" correspondant aux informations du Document que l'on souhaite afficher struct DocumentJSON<'a>{ is_ok: bool, headers: HeadersJSON<'a>, message: HashMap<&'a str, FieldJSON<'a>>, is_signature_valid: bool, annex: &'a str, is_document_valid: bool } struct FieldJSON<'a>{ name: &'a str, value: &'a str, is_valid: bool, #[serde(skip_serializing_if = \"Option::is_none\")] errors: Option<Vec<String>> } struct HeadersJSON<'a>{ marqueur : &'a str, version : u8, identifiant_de_ac : &'a str, identifiant_du_certificat : &'a str, date_emission : &'a str, date_signature: &'a str, type_document: &'a str, type_document_description: &'a str, #[serde(skip_serializing_if = \"Option::is_none\")] perimetre : Option<&'a str>, #[serde(skip_serializing_if = \"Option::is_none\")] pays_emetteur : Option<&'a str>, } struct ErrorJSON<'a>{ is_ok: bool, kind: String, value: &'a str } Copy info Des exemples de sortie sont disponible ici "},{"title":"ğŸ“ SpÃ©cifications","type":0,"sectionRef":"#","url":"docs/Modules_externes/securite/securite_specs","content":"","keywords":""},{"title":"âš™ Principeâ€‹","type":1,"pageTitle":"ğŸ“ SpÃ©cifications","url":"docs/Modules_externes/securite/securite_specs#-principe","content":"Les 2DDoc sont signÃ©s pour permettre leur vÃ©rification. La liste des TLS (Trust Service Provider) : AutoritÃ©es ayant un certificat RACINE (cert_racine) (identifiÃ© par leur Identifiant de lâ€™AutoritÃ© de Certification ex: FR01). Elles sont listÃ©es dans un fichier XML sur le site de l'ANTS (ex 20210927-TLS_2.xml) Pour chaque autoritÃ©, le fichier XML contient un URL pour rÃ©cupÃ©rer le certificat (cert_fils) ayant signÃ© un 2DDoc, identifiÃ© par un Identifiant du certificat ex: AV01On peut vÃ©rifier l'authenticitÃ© de cert_fils Ã  l'aide de cert_racine. Il est donc nÃ©cessaire d'avoir les cert_racine dans le binaire du programmeIl existe aussi pour chaque autoritÃ© une liste de cert_fils rÃ©voquÃ©s "},{"title":"ğŸ§° MÃ©thodeâ€‹","type":1,"pageTitle":"ğŸ“ SpÃ©cifications","url":"docs/Modules_externes/securite/securite_specs#-mÃ©thode","content":"Extraire la signatureExtraire lâ€™en-tÃªteRÃ©cupÃ©rer l'Identifiant de lâ€™AutoritÃ© de Certification (AC) RÃ©cupÃ©rer le cert_racine correspondant Ã  ACRÃ©cupÃ©rer l'URL pour trouver le cert_fils RÃ©cupÃ©rer l'Identifiant du certificat (AC_NUM) RÃ©cupÃ©rer le cert_fils correspondant Ã  AC_NUMValider cert_fils avec cert_racineVÃ©rifier si cert_fils est revoquÃ© VÃ©rifier la signature avec cert_fils On obtient le certificat cert_fils, et on a vÃ©rifier que celui-ci est bien authentique. "},{"title":"ğŸ” VÃ©rifier la signatureâ€‹","type":1,"pageTitle":"ğŸ“ SpÃ©cifications","url":"docs/Modules_externes/securite/securite_specs#-vÃ©rifier-la-signature","content":"RÃ©cupÃ©rer la signature du messageRÃ©cuperer la clÃ©e publique de cert_fils (ie. extraire du certificat)(Calculer un Digest (=hash) du message)A partir de la clÃ©e publique, de la signature ( et du digest OU message ), valider la signature "},{"title":"ğŸ” Format des donnÃ©es de certificationâ€‹","type":1,"pageTitle":"ğŸ“ SpÃ©cifications","url":"docs/Modules_externes/securite/securite_specs#-format-des-donnÃ©es-de-certification","content":".cer .crt .der => certificat DER au format binaire.pem => certificat DER encodÃ© en Base64, encadrÃ© par les mentions \"-----BEGIN CERTIFICATE-----\" et \"-----END CERTIFICATE-----\" tip Pour manipuler les certificats \"a la main\", ou prÃ©parer les tests: # Certificat X509: PEM -> DER openssl x509 -in AV01.der -inform DER > AV01.pem # SI DER: -inform DER # Certificat X509 PEM: Infos openssl x509 -text -noout # Certificat PEM -> ClÃ©e publique openssl x509 -pubkey -noout Copy "},{"title":"ğŸ“– README","type":0,"sectionRef":"#","url":"docs/project/README","content":"","keywords":""},{"title":"ğŸš€ Introductionâ€‹","type":1,"pageTitle":"ğŸ“– README","url":"docs/project/README#-introduction","content":"ğŸ“š documentation FR Le 2D-DOC est une spÃ©cification de datamatrix permettant Ã  lâ€™administration franÃ§aise dâ€™embarquer des informations certifiÃ©s dans un document papier. On peut citer comme exemple les justificatifs de domiciles ou les attestations vaccinales. Le but de ce projet est de crÃ©er une librairie en rust permettant dâ€™interprÃ©ter le flux dâ€™octets provenant dâ€™un datamatrix en donnÃ©es structurÃ©es suivant les spÃ©cifications de 2D-DOC.  EN The 2D-DOC is a datamatrix specification allowing the French administration to embed certified information in a paper document. We can quote as example the proofs of residence or the vaccine certificates. The goal of this project is to create a library in rust allowing to interpret the flow of bytes coming from a datamatrix in a structured data format, according to the 2D-DOC specifications. "},{"title":"ğŸ›  Compilationâ€‹","type":1,"pageTitle":"ğŸ“– README","url":"docs/project/README#-compilation","content":"Cargo va crÃ©er une librairie .rlib et .so dans le dossier target/ "},{"title":"Installation rustâ€‹","type":1,"pageTitle":"ğŸ“– README","url":"docs/project/README#installation-rust","content":"curl https://sh.rustup.rs -sSf | sh "},{"title":"Installation dÃ©pendancesâ€‹","type":1,"pageTitle":"ğŸ“– README","url":"docs/project/README#installation-dÃ©pendances","content":"apt install build-essential pkg-config libssl-dev libdmtx-dev "},{"title":"Compilation librairieâ€‹","type":1,"pageTitle":"ğŸ“– README","url":"docs/project/README#compilation-librairie","content":"cargo build --release "},{"title":"ğŸ“š Documentationâ€‹","type":1,"pageTitle":"ğŸ“– README","url":"docs/project/README#-documentation","content":"Une documentation complÃ¨te est disponible ici On dÃ©taille le projet, les spÃ©cifications 2DDoc, l'implÃ©mentation et les modules externes utilisÃ©s cd website npm run build npm run serve Copy "},{"title":"ğŸ“š Librairie","type":0,"sectionRef":"#","url":"docs/project/FFI_out","content":"","keywords":""},{"title":"â¤ Rustâ€‹","type":1,"pageTitle":"ğŸ“š Librairie","url":"docs/project/FFI_out#-rust","content":"Via libr2ddoc.rlib pub fn data_to_document(data: &[u8]) -> Result<Document, ErrorDocument> pub fn data_to_json(data: &[u8]) -> String pub fn image_to_document(pxls: &[u8], width: u32, height: u32, format: PackOrder) -> Result<Document, ErrorDocument> pub fn image_to_json(pxls: &[u8], width: u32, height: u32, format: PackOrder) -> String Copy "},{"title":"ğŸ’” Câ€‹","type":1,"pageTitle":"ğŸ“š Librairie","url":"docs/project/FFI_out#-c","content":"Via libr2ddoc.so //libr2ddoc.h char *lib2ddoc_data_to_json(unsigned char *data, int length); char *lib2ddoc_image_to_json(unsigned char *pxls, int width, int height, int PackOrder); void lib2ddoc_free_json(char *json); Copy tip Pour faire crÃ©er une librairie .so a cargo, il modifier Cargo.toml [lib] name = \"r2ddoc\" crate-type = [\"cdylib\", \"rlib\"] Copy info La librairie s'appelle r2ddoc car on ne peut pas faire une librairie qui commence par un chiffre ğŸ¤¯ "},{"title":"ğŸš€ FFI libDMTX","type":0,"sectionRef":"#","url":"docs/Modules_externes/ffi","content":"","keywords":""},{"title":"ğŸ“ libDMTXâ€‹","type":1,"pageTitle":"ğŸš€ FFI libDMTX","url":"docs/Modules_externes/ffi#-libdmtx","content":"Tout d'abord, pour avoir accÃ¨s a la commande dmtxread, on utilise la commande suivante  apt install dmtx-utils Copy Maintenant, on veut crÃ©er une interface en rust de la librairie libdmtx apt install libdmtx Copy "},{"title":"ğŸ“™ Manâ€‹","type":1,"pageTitle":"ğŸš€ FFI libDMTX","url":"docs/Modules_externes/ffi#-man","content":"Le man de libDmtx nous donne le code suivant pour dÃ©coder une matrice: int main(int argc, char * argv[]) { img = dmtxImageCreate(pxl, width, height, DmtxPack24bppRGB); assert(img != NULL); dec = dmtxDecodeCreate(img, 1); assert(dec != NULL); reg = dmtxRegionFindNext(dec, NULL); if (reg != NULL) { msg = dmtxDecodeMatrixRegion(dec, reg, DmtxUndefined); if (msg != NULL) { fputs(\"output: \\\"\", stdout); fwrite(msg -> output, sizeof(unsigned char), msg -> outputIdx stdout); fputs(\"\\\"\\n\", stdout); dmtxMessageDestroy( & msg); } dmtxRegionDestroy( & reg); } dmtxDecodeDestroy( & dec); dmtxImageDestroy( & img); free(pxl); exit(0); } Copy tip dmtxImageCreate Cette fonction prend comme 4e argument un packOrder, cela correspond Ã  l'arrangement des pixels dans le vecteur plat pxl. dmtxDecodeCreate Le 2e argument de cette fonction est un facteur d'agrandissement, inutile dans notre cas. dmtxRegionFindNext Le 2e argument de cette fonction est un timeout pour la recherche, via la structure DmtxTime typedef struct DmtxTime_struct { time_t sec; unsigned long usec; } DmtxTime; Copy "},{"title":"ğŸš€ Foreign Function Interface.â€‹","type":1,"pageTitle":"ğŸš€ FFI libDMTX","url":"docs/Modules_externes/ffi#-foreign-function-interface","content":"Une interface de fonction Ã©trangÃ¨re (FFI) est un mÃ©canisme par lequel un programme Ã©crit dans un langage de programmation peut appeler des routines ou utiliser des services Ã©crits dans un autre langage. https://doc.rust-lang.org/nomicon/ffi.html extern crate libc; use libc::size_t; #[link(name = \"snappy\")] extern { fn snappy_max_compressed_length(source_length: size_t) -> size_t; } fn main() { let x = unsafe { snappy_max_compressed_length(100) }; println!(\"max compressed length of a 100 byte buffer: {}\", x); } Copy  "},{"title":"ğŸ“Œ Notre casâ€‹","type":1,"pageTitle":"ğŸš€ FFI libDMTX","url":"docs/Modules_externes/ffi#-notre-cas","content":"On veut avoir une FFI sur libDMTX, on utilise bindgen pour avoir des \"headers\" de libDMTX depuis les headers .h, et c'est cargo qui va linker la librairie lors de la compilation ! "},{"title":"ğŸ£ ANTS -> JSON","type":0,"sectionRef":"#","url":"docs/Implementation/Specifications/GDoc+GDoc->JSON","content":"","keywords":""},{"title":"ğŸ“ Principeâ€‹","type":1,"pageTitle":"ğŸ£ ANTS -> JSON","url":"docs/Implementation/Specifications/GDoc+GDoc->JSON#-principe","content":"Pour pouvoir dÃ©coder des 2DDOC, nous avons besoin de certaines informations du fichier de spÃ©cification de l'ANTS: Section 6 : Types de documentsSection 7 : Identifiants (ID)Section 8 : ID dans chaque type de documents Ces informations permettent notamment de vÃ©rifier la validitÃ© d'un ID (taille, valeur ...), ou encore les DI obligatoires pour chaque document. Nous avons d'abord rassemblÃ© ces donnÃ©es dans un tableur (depuis le fichier PDF). Ensuite, nous avons dÃ©veloppÃ© un script permettant de rassembler ces donnÃ©es dans un fichier JSON propre Ã  chaque section. "},{"title":"ğŸ›  Exemple pour la section S6:â€‹","type":1,"pageTitle":"ğŸ£ ANTS -> JSON","url":"docs/Implementation/Specifications/GDoc+GDoc->JSON#-exemple-pour-la-section-s6","content":"function subarray_push(array, i, j, value) { let al = array.length; for(var k=0;k<(i-al+1);k++){ array.push([]); } al = array[i].length; for(var k=0;k<(j-al+1);k++){ array[i].push([]); } array[i][j].push(value); } function s6() { var ss = SpreadsheetApp.getActiveSpreadsheet(); var sheet = ss.getSheetByName(\"Section 6\"); var range = sheet.getDataRange(); var values = range.getValues(); var data = {}; values.forEach((row, i) => { if(row[0] == '') return; data[row[1]] = { 'type': row[0], 'date_emission': row[2] == 'O' ? true : false, 'description': row[3] }; }) sheet.appendRow(['', 'JSON: ', JSON.stringify(data)]); } Copy info Le script complet ainsi que le tableur sont disponible en Annexe. "},{"title":"Structure des fichiers de specsâ€‹","type":1,"pageTitle":"ğŸ£ ANTS -> JSON","url":"docs/Implementation/Specifications/GDoc+GDoc->JSON#structure-des-fichiers-de-specs","content":"Section6.json [ { \"type\": \"Justificatif de domicile\", \"code\": \"00\", \"date_emission\": true, \"description\": \"Document Ã©mis spÃ©cifiquement pour servir de justificatif de domicile.\" } ] Copy Section7.json [ { \"id\": \"01\", \"nom\": \"Identifiant unique du document.\", \"taille_min\": 0, \"taille_max\": -1, \"type\": \"AlphanumÃ©rique\", \"description\": \"Cet identifiant permet en fonction de lâ€™Ã©metteur (si celui-ci fournit le service) de rÃ©cupÃ©rer le document correspondant. Cette donnÃ©e est encodÃ©e en utilisant uniquement des lettres majuscules non accentuÃ©es [A-Z] et des chiffres [0-9].\", \"conditions\": \"MAJ+CHIFFRES\" } ] Copy Section8.json { \"<S6>\": { \"obligatoire\": [\"<S7>\", \"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\"], \"facultatif\": [\"<S7>\", \"1K\",\"1J\",\"1I\",\"1G\"], \"conditions\": [ [ //A OU B [\"<S7>\", \"DK \", \"DL\"], [\"DM\", \"DN\", \"DO\", \"DP\"] ], [ // C OU D [\"DQ\", \"DR\",\"DS\"], [\"DT\"] ] ] } } Copy "},{"title":"ğŸ’­ UML","type":0,"sectionRef":"#","url":"docs/project/UML","content":"ğŸ’­ UML caution Rust n'Ã©tant pas un langage orientÃ© objet, ceci n'est qu'un concept gÃ©nÃ©ral !","keywords":""},{"title":"âš¡ GitLab CI/CD","type":0,"sectionRef":"#","url":"docs/project/CI_CD","content":"","keywords":""},{"title":"ğŸ“ Explicationâ€‹","type":1,"pageTitle":"âš¡ GitLab CI/CD","url":"docs/project/CI_CD#-explication","content":"GitLab CI/CD est une fonctionnalitÃ© qui permet de mettre en place des pipelines de CI/CD pour n'importe quel projet, qu'il soit nouveau ou existant, pourvu qu'il utilise Git. Il nous permet d'automatiser les Ã©tapes : d'intÃ©gration continue : Build > Tests (unitaires, d'intÃ©gration, de non-rÃ©gression...) de dÃ©ploiement continu : Review > DÃ©ploiement (staging, production...) Cette automatisation accÃ©lÃ¨re la production de code : un seul commit suffit Ã  dÃ©clencher une pipeline cÃ´tÃ© GitLab qui s'occupera de gÃ©nÃ©rer un build de production, lancer la suite de tests et dÃ©ployer la nouvelle version en staging/production ! Cela permet Ã©galement d'augmenter la confiance des dÃ©veloppeurs et la qualitÃ© du code envoyÃ© en production, car on a l'assurance que chaque modification est passÃ©e par ce processus. "},{"title":"âš’ Pratiqueâ€‹","type":1,"pageTitle":"âš¡ GitLab CI/CD","url":"docs/project/CI_CD#-pratique","content":"caution Gitlab ne garde qu'un seul site par projet. On utilise AWS pour sauvegarder tous les sites de toutes les branches stages: - build - test - deploy build_rust: stage: build image: rust:latest before_script: - apt update && apt -y install libdmtx-dev script: - echo \"Building library...\" - cargo build test_rust: stage: test image: rust:latest needs: - build_rust before_script: - apt update && apt -y install libdmtx-dev script: - echo \"Testing library...\" - cargo test #Build once for gitlab pages (to ../public). And a second time for live URL. pages: stage: build image: node:15.12-alpine3.13 script: - cd website - yarn install - yarn build - mv ./build ../public - >- sed -i -e \"s/baseUrl: '\\/lib2ddoc\\/',/baseUrl: '\\/$CI_COMMIT_SHORT_SHA\\/',/g\" docusaurus.config.js - >- sed -i -e \"s/url: 'https:\\/\\/pages.gitlab.io',/url: 'https:\\/\\/lib2ddoc.aws.ipv4.ovh',/g\" docusaurus.config.js - yarn build - mv ./build ../public2 artifacts: paths: - public - public2 deploy_website: stage: deploy needs: - pages image: registry.gitlab.com/gitlab-org/cloud-deploy/aws-base:latest script: - >- aws s3 sync public2/ \"s3://ovh.ipv4.aws.lib2ddoc/$CI_COMMIT_SHORT_SHA/\" Copy "},{"title":"ğŸŒ Site Web","type":0,"sectionRef":"#","url":"docs/project/website","content":"","keywords":""},{"title":"ğŸ›  Constructionâ€‹","type":1,"pageTitle":"ğŸŒ Site Web","url":"docs/project/website#-construction","content":"Docusaurus est un gÃ©nÃ©rateur de site web statique donc nous avons besoin de construire le site web dans un rÃ©pertoire de contenu statique et de le mettre sur un serveur web pour qu'il puisse Ãªtre consultÃ©. Pour construire le site web : cd website npm run build Copy "},{"title":"ğŸš€ ExÃ©cutionâ€‹","type":1,"pageTitle":"ğŸŒ Site Web","url":"docs/project/website#-exÃ©cution","content":"tip Docusaurus possÃ¨de une fonctionalitÃ© de hot-reload ! cd website npm run start Copy "},{"title":"âœ Nouveau documentâ€‹","type":1,"pageTitle":"ğŸŒ Site Web","url":"docs/project/website#-nouveau-document","content":"CrÃ©ez un fichier Markdown et placez-le dans le rÃ©pertoire docs/: â”œâ”€â”€ docs â”‚ â””â”€â”€ hello-world.md â”œâ”€â”€ docusaurus.config.js â”œâ”€â”€ ... Copy De la mÃªme maniÃ¨re, une page sera crÃ©Ã©e Ã  l'adresse http://localhost:3000/docs/hello. Maintenant, il faut ajouter le path du markdown crÃ©Ã© dans le fichier sidebars.js et docusaurus.config.js "},{"title":"ğŸ”¥ DÃ©monstration","type":0,"sectionRef":"#","url":"docs/project/Demo","content":"","keywords":""},{"title":"Un passe sanitaireâ€‹","type":1,"pageTitle":"ğŸ”¥ DÃ©monstration","url":"docs/project/Demo#un-passe-sanitaire","content":"note Ce document est un document factice, dÃ©diÃ© aux tests !  "},{"title":"DonnÃ©esâ€‹","type":1,"pageTitle":"ğŸ”¥ DÃ©monstration","url":"docs/project/Demo#donnÃ©es","content":"Texte:â€‹ info C'est ce que contient le datamatrix (2d-doc) DC04FR0000011E581E58B201FRF0DEPOTHPRIM\u001dF1NEG\u001dF201011955F3FF4945006\u001dF5NF6070420211010\u001fMRZICP23SZTCLV2APC5P2AQVZDKHDKRG5KOIYGBKDXUA7N5O75QLWMKJBFSL3WJZYG2HHF4Z3K5E6E2GJFOVSV7E2W2XVHEXXVDXYNY JSON:â€‹ info C'est ce que renvoie notre programme { \"is_ok\": true, \"headers\": { \"marqueur\": \"DC\", \"version\": 4, \"identifiant_de_ac\": \"FR00\", \"identifiant_du_certificat\": \"0001\", \"date_emission\": \"1E58\", \"date_signature\": \"1E58\", \"type_document\": \"B2\", \"type_document_description\": \"Test COVID\", \"perimetre\": \"01\", \"pays_emetteur\": \"FR\" }, \"message\": { \"F6\": { \"name\": \"Date et heure du prÃ©lÃ¨vement\", \"value\": \"070420211010\", \"is_valid\": true }, \"F3\": { \"name\": \"Genre\", \"value\": \"F\", \"is_valid\": true }, \"F4\": { \"name\": \"Code analyse\", \"value\": \"945006\", \"is_valid\": true }, \"F0\": { \"name\": \"Liste des prÃ©noms\", \"value\": \"DEPOTHPRIM\", \"is_valid\": true }, \"F2\": { \"name\": \"Date de naissance\", \"value\": \"01011955\", \"is_valid\": true }, \"F5\": { \"name\": \"RÃ©sultat de lâ€™analyse\", \"value\": \"N\", \"is_valid\": true }, \"F1\": { \"name\": \"Nom patronymique\", \"value\": \"NEG\", \"is_valid\": true } }, \"is_signature_valid\": true, \"annex\": \"\", \"is_document_valid\": true } Copy "},{"title":"ğŸ”“ Zone Annexe","type":0,"sectionRef":"#","url":"docs/Specifications/Annexe","content":"ğŸ”“ Zone Annexe Par besoin de faire varier certains Ã©lÃ©ments du code 2D-DOC, la version 04 intÃ¨gre une zone annexe Ã  la fin du code aprÃ¨s la zone de signature. Le format de lâ€™annexe est la mÃªme que la zone de message, cependant puisque celle-ci nâ€™est pas prise en compte dans la signature ses informations ne peuvent pas Ãªtre vÃ©rifiÃ©es. Ainsi il faut prendre des prÃ©cautions avec ce message annexe car les donnÃ©es pourraient Ãªtre frauduleuses. Un exemple dâ€™utilitÃ© de lâ€™annexe est dans le cas oÃ¹ le 2D-DOC contient les caractÃ©ristiques dâ€™un produit et son numÃ©ro de sÃ©rie. On souhaite crÃ©er un 2D-DOC pour chaque produit mais cela est coÃ»teux si lâ€™on doit intÃ©grer Ã  chaque fois le numÃ©ro de sÃ©rie alors que les caractÃ©ristiques du produit restent les mÃªmes. Ainsi, en ajoutant le numÃ©ro de sÃ©rie dans lâ€™annexe on peut le faire varier pour chaque Ã©lÃ©ment produit. Pour insÃ©rer un bloc de donnÃ©es annexe en format C40 il faut insÃ©rer le sÃ©parateur <GS> Ã  la fin de la signature mais pas en format binaire.","keywords":""},{"title":"ğŸ”‘ Signature","type":0,"sectionRef":"#","url":"docs/Specifications/Signature","content":"ğŸ”‘ Signature Cliquer ici pour Ãªtre redirigÃ© vers le module SÃ©curitÃ©","keywords":""},{"title":"âš“ Introduction","type":0,"sectionRef":"#","url":"docs/Specifications/Introduction","content":"âš“ Introduction Le but du 2D-DOC est de lutter contre la fraude documentaire. La fraude documentaire est un terme gÃ©nÃ©rique qui permet de dÃ©signer la falsification d'un document. Aujourdâ€™hui, avec la crise de la Covid 19 les menaces liÃ©es aux fraudes se sont accentuÃ©es, cela dÃ» au fait de la hausse du tÃ©lÃ©travail et lâ€™utilisation des outils informatiques personnels. Pour lutter contre la fraude documentaire, le 2D-DOC doit atteindre cinq objectifs: SÃ©curitÃ© InteropÃ©rabilitÃ© UniformitÃ© FacilitÃ© d'usage DurabilitÃ© Le 2D-DOC doit Ã©galement permettre de simplifier et digitaliser les dÃ©marches administratives des usagers. Le premier objectif de sÃ©curitÃ© implique que les donnÃ©es doivent Ãªtre chiffrÃ©es. En effet, dans le 2D-DOC lâ€™information est contenue dans un code Ã  barres 2D (DataMatrix) qui emporte les informations clÃ©s du document, la date dâ€™Ã©mission et la signature Ã©lectronique de ces donnÃ©es. Câ€™est l'Ã©metteur qui rÃ©alise ce code Ã  barres. Le code est sÃ©curisÃ© Ã  l'aide d'une signature numÃ©rique fondÃ©e sur une cryptographie asymÃ©trique. (clÃ© publique/clÃ© privÃ©e) qui permet le contrÃ´le de la signature par tous les acteurs disposant de la clÃ© publique du signataire Ã©metteur. La vÃ©rification du code-barre se fait grÃ¢ce Ã  un scanner qui vÃ©rifie lâ€™exactitude des donnÃ©es. note Ces prÃ©cautions de cryptage permettent dâ€™Ã©viter les fuites dâ€™informations qui peuvent Ãªtre trÃ¨s coÃ»teuses. Par exemple, la plus grande violation de sÃ©curitÃ© a eu lieu en 2011 et a coÃ»tÃ© Ã  l'entreprise Epsilon plus de 4 milliard de dollars.","keywords":""},{"title":"ğŸ© En-tÃªte","type":0,"sectionRef":"#","url":"docs/Specifications/Entete","content":"","keywords":""},{"title":"ğŸ“„ Descriptionâ€‹","type":1,"pageTitle":"ğŸ© En-tÃªte","url":"docs/Specifications/Entete#-description","content":"Il y a diffÃ©rentes versions d'en-tÃªte utilisÃ©es pour le dispositif 2D-DOC. Lâ€™en-tÃªte contient les informations qui permettent de dÃ©coder et de vÃ©rifier les informations du 2D-DOC. La longueur de lâ€™en-tÃªte est de 22 bits pour les versions â€˜01â€™, â€˜02â€™, 24 bits pour la version â€˜03â€™ et 26 bits pour la version â€˜04â€™ car on ajoute des informations en plus dans les versions â€˜03â€™ et â€˜04â€™. Lâ€™en-tÃªte contient tout ce qui est reliÃ© Ã  l'identification du document. Ces informations permettent dâ€™interprÃ©ter lâ€™information contenu dans un 2D-DOC car elles fournissent le type de Code 2D-DOC, la version du code, les identifiants etc. Tout dâ€™abord , on retrouve dans l'en-tÃªte un marqueur dâ€™identification du document. Celui-ci prend toujours la valeur DC. Ensuite on a la version du 2D-DOC (eg. 02) Puis on a lâ€™Identifiant de lâ€™AutoritÃ© de Certification ayant dÃ©livrÃ© le certificat utilisÃ© par lâ€™Ã©metteur du document pour signer les DonnÃ©es. En fonction du format de codage, celui-ci peut Ãªtre codÃ© sur 4 caractÃ¨res alphanumÃ©riques (format C40) ou sur 5 caractÃ¨res hexadÃ©cimaux (format BINAIRE). Un exemple dâ€™Identifiant de lâ€™AutoritÃ© de Certification est Certigna FR03 (Service de sÃ©curitÃ© informatique) ou Ariadnext FR04 (Entreprise de logiciels). AprÃ¨s, on a lâ€™Identifiant du Certificat utilisÃ© pour signer les donnÃ©es sur quatre caractÃ¨res alphanumÃ©riques. Ainsi on rÃ©cupÃ¨re les certificats via des Annuaire de certificats qui suivent la norme RFC 4387. Ce certificat contient une clÃ© publique qui est distribuÃ©e aux tierces parties intÃ©ressÃ©es par la vÃ©rification du code 2D-Doc. Ce certificat ne peut Ãªtre stockÃ© directement dans le 2D-DOC car il y aurait trop dâ€™informations Ã  coder dans le code Ã  barres et celui-ci serait beaucoup trop grand. (eg. AB04) on a Ã©galement la date d'Ã©mission et la date de signature du document codÃ© en hexadÃ©cimal depuis le premier janvier 2000. Par exemple, la date du 29 avril 2021 correspond Ã  1E6D. Enfin, le code dâ€™identification du type de document (dÃ©tails) sur deux caractÃ¨res alphanumÃ©riques. La version â€˜03â€™ du 2D-DOC se diffÃ©rencie des versions prÃ©cÃ©dentes par lâ€™ajout dâ€™un champ pour lâ€™identifiant du pÃ©rimÃ¨tre sur lequel le type de document est dÃ©fini. Pour l'instant, l'ensemble des documents est sous lâ€™identifiant 01 (pÃ©rimÃ¨tre ANTS). La version â€˜04â€™ du 2D-DOC on ajoute lâ€™information Pays Ã©metteur du document. Pour la France, cela correspond au code FR. note On obtient un code de la forme suivante pour lâ€™en-tÃªte des versions C40 â€˜01â€™ et â€˜02â€™ :DC02ANTSXT4A1E6D1E6D01 "},{"title":"âš’ RÃ©capitulatifâ€‹","type":1,"pageTitle":"ğŸ© En-tÃªte","url":"docs/Specifications/Entete#-rÃ©capitulatif","content":"En-tÃªte dâ€™un code 2D-Doc en C40 pour la version 04 :  "},{"title":"ğŸ“’ Format gÃ©nÃ©ral","type":0,"sectionRef":"#","url":"docs/Specifications/Format_2DDoc","content":"","keywords":""},{"title":"ğŸ“ Structureâ€‹","type":1,"pageTitle":"ğŸ“’ Format gÃ©nÃ©ral","url":"docs/Specifications/Format_2DDoc#-structure","content":"Un code 2D-Doc est constituÃ© de plusieurs champs, deux champs principaux et un champ optionnel: la zone de donnÃ©es la signature des donnÃ©esÃ©ventuellement des donnÃ©es annexes. La zone de donnÃ©es des donnÃ©es est composÃ© lui-mÃªme de deux sous-zones: La zone d'en-tÃªte contient les informations nÃ©cessaires pour dÃ©coder et vÃ©rifier le Code 2D-Doc. La zone de message contient les informations propres Ã  chaque code 2D-Doc. Le message est reprÃ©sentÃ© par une suite de couples (id,donnÃ©es). Le champ de la signature contient l'information qui nous permet de vÃ©rifier l'intÃ©gralitÃ© de nos donnÃ©es. Enfin, le champ de donnÃ©es annexe optionnelle a la mÃªme structure que la zone de message mais se trouve aprÃ¨s la zone de signature. Puisque câ€™est un champ optionnel, son contenu nâ€™est pas pris en compte dans la signature.  "},{"title":"âš’ Formatsâ€‹","type":1,"pageTitle":"ğŸ“’ Format gÃ©nÃ©ral","url":"docs/Specifications/Format_2DDoc#-formats","content":"Plusieurs versions du 2D-DOC ont Ã©tÃ© mises Ã  jour dÃ¨s son dÃ©but: "},{"title":"ğŸ”  C40â€‹","type":1,"pageTitle":"ğŸ“’ Format gÃ©nÃ©ral","url":"docs/Specifications/Format_2DDoc#-c40","content":"Le format C40 est utilisÃ© pour encoder des donnÃ©es constituÃ©es essentiellement de caractÃ¨res majuscules. Il transforme trois caractÃ¨res alphanumÃ©riques en deux octets grÃ¢ce Ã  un tableau de caractÃ¨res rÃ©duit Ã  40 caractÃ¨res, encodÃ©s en base 40. Lâ€™avantage du format C40 câ€™est quâ€™il permet dâ€™atteindre la capacitÃ© maximum alphanumÃ©rique en utilisant uniquement des chiffres, des espaces et des majuscules. Câ€™est donc un codage optimisÃ© qui limite Ã©galement la taille des donnÃ©es. Un autre avantage du format C4O est quâ€™il est lisible sur diffÃ©rentes plateformes et interprÃ©table par diffÃ©rents lecteurs Ã  code barre. "},{"title":"ğŸ”¢ Binaireâ€‹","type":1,"pageTitle":"ğŸ“’ Format gÃ©nÃ©ral","url":"docs/Specifications/Format_2DDoc#-binaire","content":"Le format binaire utilise un codage binaire c'est-Ã -dire le systÃ¨me de numÃ©rotation en base 2, il permet par exemple d'inclure de petites (images) dans les 2DDocs. Ci-dessus des exemples de format 2D-DOC. On remarque que les versions â€˜01â€™ Ã  â€˜04â€™ contiennent un message C40, et la signature de la version â€˜01â€™ est en binaire puis en C40 dans les versions â€˜02â€™, â€˜03â€™ et â€˜04â€™. Enfin le quatriÃ¨me bloc: lâ€™annexe, est optionnel. "},{"title":"ğŸ“¨ Zone de Message","type":0,"sectionRef":"#","url":"docs/Specifications/Message","content":"","keywords":""},{"title":"ğŸ”  Zone de message C40â€‹","type":1,"pageTitle":"ğŸ“¨ Zone de Message","url":"docs/Specifications/Message#-zone-de-message-c40","content":"En C40, lâ€™en-tÃªte a une taille fixe de 26 caractÃ¨res alphanumÃ©riques avant encodage. Un message est constituÃ© dâ€™une suite de blocs de donnÃ©es. Les blocs de donnÃ©es contiennent les Ã©lÃ©ments suivants: un identifiant de donnÃ©e ID codÃ© sur deux caractÃ¨resla donnÃ©e elle-mÃªme encodÃ©e au format C40un caractÃ¨re de fin de donnÃ©e appelÃ© sÃ©parateur (<GS>) lorsquâ€™un bloc de donnÃ©es nâ€™a pas une taille fixe Finalement, le caractÃ¨re <RS> indique la fin de la zone de message  "},{"title":"ğŸ”¢ Zone de message Binaireâ€‹","type":1,"pageTitle":"ğŸ“¨ Zone de Message","url":"docs/Specifications/Message#-zone-de-message-binaire","content":"Lâ€™identifiant de donnÃ©e (ID) est codÃ© sur un octet (La valeur 0xFF nâ€™est pas autorisÃ©e: elle est rÃ©servÃ©e pour indiquer le dÃ©but de la signature) puis suivi dâ€™un ou trois octets pour indiquer la taille de la donnÃ©e qui suit. Si la donnÃ©e est nulle alors lâ€™octet prend la valeur de 0x00 "},{"title":"ğŸ“š Types de documents","type":0,"sectionRef":"#","url":"docs/Specifications/Types_de_documents","content":"ğŸ“š Types de documents Les diffÃ©rents types de documents au format C40 avec un exemple attribuÃ© par chacun: Type de document\tExemple\tID exempleJustificatif de domicile\tFactures de tÃ©lÃ©phonie\t01 Justificatif de domiciliation bancaire\tRelevÃ© dâ€™IdentitÃ© bancaire\t03 Justificatif de ressources\tBulletin de salaire\t06 Justificatif dâ€™identitÃ©\tDocument Ã©tranger\t13 Justificatif fiscal\tFacture Ã©tendue\t09 Justificatif dâ€™emploi\tContrat de travail\t10 Justificatif de vÃ©hicule\tCertificat de qualitÃ© de lâ€™air\tA0 Justificatif permis de conduire\tCourrier Permis Ã  Points\tA1 Justificatif de santÃ©\tCarte MobilitÃ© Inclusion (CMI)\tA2 Justificatif dâ€™activitÃ©\tPermis de chasser\tA9 Justificatif mÃ©dical\tCertificat de dÃ©cÃ¨s\tA4 Justificatif acadÃ©mique\tDiplÃ´me\tB0 Justificatif juridique/judiciaire\tActe dâ€™huissier\t12 Certificat dâ€™immatriculation\tCertificat de cession Ã©lectronique\tA8 Autorisations douaniÃ¨res\tLicence dâ€™exportation dâ€™armes Ã  feu\tC5 RÃ©sultats des tests virologiques\tTest COVID\tB2 Attestation Vaccinale\tAttestation Vaccinale\tL1 Justificatif dâ€™Asile\tAttestation de Demande dâ€™Asile\t16","keywords":""}]