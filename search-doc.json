[{"title":"❌ Erreur","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Error","content":"❌ Erreur On dispose d'un type d'erreur propre pour les erreurs de décodage: pub enum ErrorKind { General, Impossible, NoMatrix, FieldZoneDecoder, Decoder, Signing } pub struct Error{ pub kind: ErrorKind, pub value: String } Copy Nous avons à peu près un type par module, et on ajoute une description détaillé dans le champ value.","keywords":""},{"title":"🧰 FieldZoneDecoder","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Message","content":"🧰 FieldZoneDecoder Un message est constitué d’une séquence de blocs de données. Chaque bloc de données est constitué des éléments suivants : D'un Identifiant de Donnée (ID) sur deux caractères.De la Donnée (D).D’un éventuel caractère de fin de donnée GS ou de troncature de donnée RS. Selon l’ID, la Donnée peut-être : De longueur fixeDe longueur variable, avec une borne supérieureDe longueur variable avec des bornes inférieure et supérieureDe longueur variable non bornée On récupère ces informations à l'aide du FieldSpecificationStore FieldSpecificationsStore::get(&id) Copy On cherche ensuite RS ou GS dans la zone [B_inf, B_sup], et on consomme la sous-chaine. info C'est aussi ici que l'on ajoute les informations de troncature A la fin, on retourne une FieldZone complète, mais pas validé.","keywords":""},{"title":"🎩 En-têtes","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Entete","content":"🎩 En-têtes Nous avons créé la structure correspondante Headers : pub struct Headers { pub marqueur : String, pub version : String, pub identifiant_de_ac : String, pub identifiant_du_certificat : String, pub date_emission : String, pub date_signature: String, pub type_document: String, pub perimetre : Option<String>, // version \"03\" pub pays_emetteur : Option<String>, // version \"04\" } Copy tip On utilise le type Option de rust, permettant d'ajouter une valeur par la suite, uniquement pour les documents ayant une version supérieure ou égale à 2 Donc au début, on a la fonction initialiser, qui parse le code et remplit chaque champs de la structure. Ensuite, en fonction de la version de l'en-tête du 2D-Doc à decrypter on remplit soit le champs perimetre, soit le champs pays-emetteur grâce à la fonction remplir cas particuliers. let mut entete = Headers ::initialiser(str); entete.remplir_cas_particuliers(str); Copy","keywords":""},{"title":"🏗 Builder","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Builder","content":"🏗 Builder On utiliser un Builder pour composer notre structure DocumentDecoded, il est en charge des fonctions suivantes: HeadersFieldZoneValidation de document (Validator)Validation de signature (Signer) let (headers, headers_size) = Headers::new(str); let document_raw = DocumentRaw::new(str, headers_size)?; let mut document_decoded = DocumentDecodedBuilder::new() .add_headers(headers) .decode_message(&document_raw.message)? .collect().to_error(ErrorKind::Decoder, String::from(\"Error decoding\"))?; let signing = Signing::verify_signature(&document_raw, &document_decoded)?; let validity = Validity::validate(&mut document_decoded); Ok(Document { raw: document_raw, decoded: document_decoded, signing, validity }) Copy","keywords":""},{"title":"🔑 Signer","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Signer","content":"🔑 Signer Pour tester la signature, on appele simplement la fonction check_signature du module externe dédié Signing{ valid: is_valid } Copy","keywords":""},{"title":"✔ Validator","type":0,"sectionRef":"#","url":"docs/Implementation/decoder/Validator","content":"✔ Validator La validation effective d'un document s'effectue après son décodage, a l'aide des elements de Specification (voir ici) On valide donc chaque DI (la FieldZone) ainsi que le Document lui même Validity{ valid: fz_valid && doc_valid } Copy","keywords":""},{"title":"🏪 SpecificationStore","type":0,"sectionRef":"#","url":"docs/Implementation/Specifications/SpecificationStore","content":"","keywords":""},{"title":"💡 Idée​","type":1,"pageTitle":"🏪 SpecificationStore","url":"docs/Implementation/Specifications/SpecificationStore#-idée","content":"Nous avons besoin des spécifications à de nombreux moments de la procédure de décodage. Nous avons donc décidé d'implémenter nos spécifications à travers une structure suivant un pattern Singleton: Une hashmap est chargée durant l'initialisation, et gardée en mémoire durant la vie du programme. Ces structures sont FieldSpecificationStore et DocumentSpecificationStore, et implémente le trait SpecificationStore  "},{"title":"🔧 JSON -> HashMap​","type":1,"pageTitle":"🏪 SpecificationStore","url":"docs/Implementation/Specifications/SpecificationStore#-json---hashmap","content":"C'est notre toolchain rust (build.rs) qui transforme le JSON en code rust, corps de l'implémentation fill de SpecificationStore. "},{"title":"🏁 Execution​","type":1,"pageTitle":"🏪 SpecificationStore","url":"docs/Implementation/Specifications/SpecificationStore#-execution","content":"Lors de l'exécution du programme, c'est une crate rust (lazy_static) qui crée une référence accessible de manière globale. On a donc bien une hashmap statique ! "},{"title":"💻 Bindgen","type":0,"sectionRef":"#","url":"docs/Modules_externes/bindgen","content":"","keywords":""},{"title":"📝 Principe​","type":1,"pageTitle":"💻 Bindgen","url":"docs/Modules_externes/bindgen#-principe","content":"Permet de transformer des .h en interface .rs Cargo recupère les sources, compile & install le binary /home/foo/.cargo/bin/bindgen apt install llvm-dev libclang-dev clang cargo install bindgen "},{"title":"🔧 Utilisation​","type":1,"pageTitle":"💻 Bindgen","url":"docs/Modules_externes/bindgen#-utilisation","content":"bindgen --allowlist-function 'dmtx.' --allowlist-type 'Dmtx.' --allowlist-var 'Dmtx.*' dmtx.h -o test.rs --no-layout-tests On précise a rust de ne pas afficher les erreurs de style de code #![allow(non_camel_case_types)] #![allow(non_snake_case)] #![allow(deref_nullptr)] #![allow(non_upper_case_globals)] #![allow(dead_code)] Copy On obtient finalement un fichier FFI pour rust, chez nous /src/libdmtx/libdmtx_sys.rs "},{"title":"🥇 Fonctions de validation","type":0,"sectionRef":"#","url":"docs/Implementation/Specifications/Fonctions_validations","content":"","keywords":""},{"title":"📝 Principe​","type":1,"pageTitle":"🥇 Fonctions de validation","url":"docs/Implementation/Specifications/Fonctions_validations#-principe","content":"Pour vérifier la validité d'un document, on doit tester deux principaux points : Si il contient bien tous les DI obligatoires.Si la valeur des DI est conforme a leurs spécifications. Pour cela, on utilise deux méthodes de validation pour chaque point: Une méthode ensembliste: On va tester si les valeurs sont présentes dans un ensemble prédéterminéUne méthode via fonction On va appliquer une fonction de validation sur les valeurs On a donc 4 fichiers lié à la validation. Les appels à ces fonctions de validation sont inclus dans les Specifications. "},{"title":"🔧 Exemple avec FieldSpecification:​","type":1,"pageTitle":"🥇 Fonctions de validation","url":"docs/Implementation/Specifications/Fonctions_validations#-exemple-avec-fieldspecification","content":" pub struct FieldSpecification{ pub id: &'static str, pub nom: &'static str, pub taille_min: i16, pub taille_max: i16, pub type_identifiant: &'static str, pub description: &'static str, pub validate: ValidatingConditionField, } pub enum ValidatingConditionField { FUNCTION(Vec<fn(&str, bool) -> Result<(), Error>>), SET(Vec<fn(&char, bool) -> Result<(), Error>>) } Copy et on a une méthode de FieldSpecification qui permet d'effectuer la validation: pub fn validate(&self, value: &str, truncated: bool) -> Result<(), Vec<Error>> Copy info On peut même tester plusieurs fonction sur un même champ, c'est-à-dire tester plusieurs conditions. "},{"title":"❌ Erreurs​","type":1,"pageTitle":"🥇 Fonctions de validation","url":"docs/Implementation/Specifications/Fonctions_validations#-erreurs","content":"De plus, on a crée un type d'erreur spécifique à la validation des documents: pub struct Error{ pub kind: ErrorKind, pub value: String } pub enum ErrorKind { General, NotInSet, FailedFunction, SizeNotRespected, InvalidCaracter, DocumentFields } Copy "},{"title":"🔨 Implémentation","type":0,"sectionRef":"#","url":"docs/Modules_externes/securite/securite_impl","content":"🔨 Implémentation L'implémentation de notre module sécurité à été pensée pour être interchangeable (pour une utilisation de openSSL par ex.) On a donc une interface unique, sous la forme d'une fonction, qui valide ou non un document: pub fn check_signature(data_zone: &str, signature: &str, authority_id: &str, certificate_id: &str) -> Result<bool, String> Copy La fonction renvoie donc un booléen correspondant à la validité du document, ou un message d'erreur. info La vérification nécessitant l'accès aux Annuaire de certificats, notre implémentation actuelle nécessite une connexion internet. Une évolution possible est l'utilisation d'un \"cache\" de certificats, pour une utilisation hors ligne.","keywords":""},{"title":"🧰 Utilisation de libDMTX en rust","type":0,"sectionRef":"#","url":"docs/Modules_externes/libDMTX_rust","content":"","keywords":""},{"title":"🔨 Librairie​","type":1,"pageTitle":"🧰 Utilisation de libDMTX en rust","url":"docs/Modules_externes/libDMTX_rust#-librairie","content":"Pour pouvoir utiliser la librairie: mod dmtx; //Pour que le compileur ajoute -ldmtx #[link(name = \"dmtx\")] extern {} Copy On obtient des signatures rust de cette forme: pub unsafe fn dmtxImageCreate(pxl: *mut std::os::raw::c_uchar, width: std::os::raw::c_int, height: std::os::raw::c_int, pack: std::os::raw::c_int) -> *mut DmtxImage Copy "},{"title":"🌮 Wrapper​","type":1,"pageTitle":"🧰 Utilisation de libDMTX en rust","url":"docs/Modules_externes/libDMTX_rust#-wrapper","content":"Attention, les signatures et les types sont au format c (avec pointeurs...) On devrait donc faire une \"safe interface\", suivant les bonnes pratiques rust. Par simplicité, on a choisit d'utiliser libDMTX de façon brut, en gardant tout le code \"unsafe\" dans une seule fonction. (/src/libdmtx/mod.rs) "},{"title":"🔧 Utilisation​","type":1,"pageTitle":"🧰 Utilisation de libDMTX en rust","url":"docs/Modules_externes/libDMTX_rust#-utilisation","content":"pub fn dmtx_read(pxl: &[u8], width: u32, height: u32, pack: DmtxPackOrder) -> Vec<u8> Copy Notre interface rust pour libdmtx prends donc en entrée un vecteur plat de pixels, la largeur et hauteur de l'image, ainsi que son packOrder. On retourne un vecteur rust contenant les données du Datamatrix , ou un vecteur vide en cas d'abscence de matrice (on donne 1s a libdmtx pour trouver la matrice) "},{"title":"📈 Améliorations","type":0,"sectionRef":"#","url":"docs/project/Ameliorations_possibles","content":"📈 Améliorations Sont ici listé les améliorations possibles: Créer une ffi propre pour libDMTX, safeFaire une implémentation via OpenSSL de security","keywords":""},{"title":"📎 Serialiser","type":0,"sectionRef":"#","url":"docs/Modules_externes/serialiser","content":"","keywords":""},{"title":"📝 Interface​","type":1,"pageTitle":"📎 Serialiser","url":"docs/Modules_externes/serialiser#-interface","content":"On propose l'interface suivante pour sérialiser un Document ou une Erreur: pub fn serialize(doc: Result<Document, ErrorDocument>) -> String Chacun est libre d'implémenter le \"sérialiseur\" qu'il préfère. "},{"title":"🧰Implémentation​","type":1,"pageTitle":"📎 Serialiser","url":"docs/Modules_externes/serialiser#implémentation","content":"Nous avons implémenté une serialisation vers JSON. En effet, ce format de données est compris par la plupart des plateformes et permet donc une grande interopérabilité Nous avons utilisé la crate rust serde, qui permet de sérialiser vers de nombreux formats. On a une \"vue\" correspondant aux informations du Document que l'on souhaite afficher struct DocumentJSON<'a>{ is_ok: bool, headers: HeadersJSON<'a>, message: HashMap<&'a str, FieldJSON<'a>>, is_signature_valid: bool, annex: &'a str, is_document_valid: bool } struct FieldJSON<'a>{ name: &'a str, value: &'a str, is_valid: bool, #[serde(skip_serializing_if = \"Option::is_none\")] errors: Option<Vec<String>> } struct HeadersJSON<'a>{ marqueur : &'a str, version : u8, identifiant_de_ac : &'a str, identifiant_du_certificat : &'a str, date_emission : &'a str, date_signature: &'a str, type_document: &'a str, type_document_description: &'a str, #[serde(skip_serializing_if = \"Option::is_none\")] perimetre : Option<&'a str>, #[serde(skip_serializing_if = \"Option::is_none\")] pays_emetteur : Option<&'a str>, } struct ErrorJSON<'a>{ is_ok: bool, kind: String, value: &'a str } Copy info Des exemples de sortie sont disponible ici "},{"title":"📝 Spécifications","type":0,"sectionRef":"#","url":"docs/Modules_externes/securite/securite_specs","content":"","keywords":""},{"title":"⚙ Principe​","type":1,"pageTitle":"📝 Spécifications","url":"docs/Modules_externes/securite/securite_specs#-principe","content":"Les 2DDoc sont signés pour permettre leur vérification. La liste des TLS (Trust Service Provider) : Autoritées ayant un certificat RACINE (cert_racine) (identifié par leur Identifiant de l’Autorité de Certification ex: FR01). Elles sont listées dans un fichier XML sur le site de l'ANTS (ex 20210927-TLS_2.xml) Pour chaque autorité, le fichier XML contient un URL pour récupérer le certificat (cert_fils) ayant signé un 2DDoc, identifié par un Identifiant du certificat ex: AV01On peut vérifier l'authenticité de cert_fils à l'aide de cert_racine. Il est donc nécessaire d'avoir les cert_racine dans le binaire du programmeIl existe aussi pour chaque autorité une liste de cert_fils révoqués "},{"title":"🧰 Méthode​","type":1,"pageTitle":"📝 Spécifications","url":"docs/Modules_externes/securite/securite_specs#-méthode","content":"Extraire la signatureExtraire l’en-têteRécupérer l'Identifiant de l’Autorité de Certification (AC) Récupérer le cert_racine correspondant à ACRécupérer l'URL pour trouver le cert_fils Récupérer l'Identifiant du certificat (AC_NUM) Récupérer le cert_fils correspondant à AC_NUMValider cert_fils avec cert_racineVérifier si cert_fils est revoqué Vérifier la signature avec cert_fils On obtient le certificat cert_fils, et on a vérifier que celui-ci est bien authentique. "},{"title":"🔐 Vérifier la signature​","type":1,"pageTitle":"📝 Spécifications","url":"docs/Modules_externes/securite/securite_specs#-vérifier-la-signature","content":"Récupérer la signature du messageRécuperer la clée publique de cert_fils (ie. extraire du certificat)(Calculer un Digest (=hash) du message)A partir de la clée publique, de la signature ( et du digest OU message ), valider la signature "},{"title":"🔏 Format des données de certification​","type":1,"pageTitle":"📝 Spécifications","url":"docs/Modules_externes/securite/securite_specs#-format-des-données-de-certification","content":".cer .crt .der => certificat DER au format binaire.pem => certificat DER encodé en Base64, encadré par les mentions \"-----BEGIN CERTIFICATE-----\" et \"-----END CERTIFICATE-----\" tip Pour manipuler les certificats \"a la main\", ou préparer les tests: # Certificat X509: PEM -> DER openssl x509 -in AV01.der -inform DER > AV01.pem # SI DER: -inform DER # Certificat X509 PEM: Infos openssl x509 -text -noout # Certificat PEM -> Clée publique openssl x509 -pubkey -noout Copy "},{"title":"📖 README","type":0,"sectionRef":"#","url":"docs/project/README","content":"","keywords":""},{"title":"🚀 Introduction​","type":1,"pageTitle":"📖 README","url":"docs/project/README#-introduction","content":"📚 documentation FR Le 2D-DOC est une spécification de datamatrix permettant à l’administration française d’embarquer des informations certifiés dans un document papier. On peut citer comme exemple les justificatifs de domiciles ou les attestations vaccinales. Le but de ce projet est de créer une librairie en rust permettant d’interpréter le flux d’octets provenant d’un datamatrix en données structurées suivant les spécifications de 2D-DOC.  EN The 2D-DOC is a datamatrix specification allowing the French administration to embed certified information in a paper document. We can quote as example the proofs of residence or the vaccine certificates. The goal of this project is to create a library in rust allowing to interpret the flow of bytes coming from a datamatrix in a structured data format, according to the 2D-DOC specifications. "},{"title":"🛠 Compilation​","type":1,"pageTitle":"📖 README","url":"docs/project/README#-compilation","content":"Cargo va créer une librairie .rlib et .so dans le dossier target/ "},{"title":"Installation rust​","type":1,"pageTitle":"📖 README","url":"docs/project/README#installation-rust","content":"curl https://sh.rustup.rs -sSf | sh "},{"title":"Installation dépendances​","type":1,"pageTitle":"📖 README","url":"docs/project/README#installation-dépendances","content":"apt install build-essential pkg-config libssl-dev libdmtx-dev "},{"title":"Compilation librairie​","type":1,"pageTitle":"📖 README","url":"docs/project/README#compilation-librairie","content":"cargo build --release "},{"title":"📚 Documentation​","type":1,"pageTitle":"📖 README","url":"docs/project/README#-documentation","content":"Une documentation complète est disponible ici On détaille le projet, les spécifications 2DDoc, l'implémentation et les modules externes utilisés cd website npm run build npm run serve Copy "},{"title":"📚 Librairie","type":0,"sectionRef":"#","url":"docs/project/FFI_out","content":"","keywords":""},{"title":"❤ Rust​","type":1,"pageTitle":"📚 Librairie","url":"docs/project/FFI_out#-rust","content":"Via libr2ddoc.rlib pub fn data_to_document(data: &[u8]) -> Result<Document, ErrorDocument> pub fn data_to_json(data: &[u8]) -> String pub fn image_to_document(pxls: &[u8], width: u32, height: u32, format: PackOrder) -> Result<Document, ErrorDocument> pub fn image_to_json(pxls: &[u8], width: u32, height: u32, format: PackOrder) -> String Copy "},{"title":"💔 C​","type":1,"pageTitle":"📚 Librairie","url":"docs/project/FFI_out#-c","content":"Via libr2ddoc.so //libr2ddoc.h char *lib2ddoc_data_to_json(unsigned char *data, int length); char *lib2ddoc_image_to_json(unsigned char *pxls, int width, int height, int PackOrder); void lib2ddoc_free_json(char *json); Copy tip Pour faire créer une librairie .so a cargo, il modifier Cargo.toml [lib] name = \"r2ddoc\" crate-type = [\"cdylib\", \"rlib\"] Copy info La librairie s'appelle r2ddoc car on ne peut pas faire une librairie qui commence par un chiffre 🤯 "},{"title":"🚀 FFI libDMTX","type":0,"sectionRef":"#","url":"docs/Modules_externes/ffi","content":"","keywords":""},{"title":"📝 libDMTX​","type":1,"pageTitle":"🚀 FFI libDMTX","url":"docs/Modules_externes/ffi#-libdmtx","content":"Tout d'abord, pour avoir accès a la commande dmtxread, on utilise la commande suivante  apt install dmtx-utils Copy Maintenant, on veut créer une interface en rust de la librairie libdmtx apt install libdmtx Copy "},{"title":"📙 Man​","type":1,"pageTitle":"🚀 FFI libDMTX","url":"docs/Modules_externes/ffi#-man","content":"Le man de libDmtx nous donne le code suivant pour décoder une matrice: int main(int argc, char * argv[]) { img = dmtxImageCreate(pxl, width, height, DmtxPack24bppRGB); assert(img != NULL); dec = dmtxDecodeCreate(img, 1); assert(dec != NULL); reg = dmtxRegionFindNext(dec, NULL); if (reg != NULL) { msg = dmtxDecodeMatrixRegion(dec, reg, DmtxUndefined); if (msg != NULL) { fputs(\"output: \\\"\", stdout); fwrite(msg -> output, sizeof(unsigned char), msg -> outputIdx stdout); fputs(\"\\\"\\n\", stdout); dmtxMessageDestroy( & msg); } dmtxRegionDestroy( & reg); } dmtxDecodeDestroy( & dec); dmtxImageDestroy( & img); free(pxl); exit(0); } Copy tip dmtxImageCreate Cette fonction prend comme 4e argument un packOrder, cela correspond à l'arrangement des pixels dans le vecteur plat pxl. dmtxDecodeCreate Le 2e argument de cette fonction est un facteur d'agrandissement, inutile dans notre cas. dmtxRegionFindNext Le 2e argument de cette fonction est un timeout pour la recherche, via la structure DmtxTime typedef struct DmtxTime_struct { time_t sec; unsigned long usec; } DmtxTime; Copy "},{"title":"🚀 Foreign Function Interface.​","type":1,"pageTitle":"🚀 FFI libDMTX","url":"docs/Modules_externes/ffi#-foreign-function-interface","content":"Une interface de fonction étrangère (FFI) est un mécanisme par lequel un programme écrit dans un langage de programmation peut appeler des routines ou utiliser des services écrits dans un autre langage. https://doc.rust-lang.org/nomicon/ffi.html extern crate libc; use libc::size_t; #[link(name = \"snappy\")] extern { fn snappy_max_compressed_length(source_length: size_t) -> size_t; } fn main() { let x = unsafe { snappy_max_compressed_length(100) }; println!(\"max compressed length of a 100 byte buffer: {}\", x); } Copy  "},{"title":"📌 Notre cas​","type":1,"pageTitle":"🚀 FFI libDMTX","url":"docs/Modules_externes/ffi#-notre-cas","content":"On veut avoir une FFI sur libDMTX, on utilise bindgen pour avoir des \"headers\" de libDMTX depuis les headers .h, et c'est cargo qui va linker la librairie lors de la compilation ! "},{"title":"🏣 ANTS -> JSON","type":0,"sectionRef":"#","url":"docs/Implementation/Specifications/GDoc+GDoc->JSON","content":"","keywords":""},{"title":"📝 Principe​","type":1,"pageTitle":"🏣 ANTS -> JSON","url":"docs/Implementation/Specifications/GDoc+GDoc->JSON#-principe","content":"Pour pouvoir décoder des 2DDOC, nous avons besoin de certaines informations du fichier de spécification de l'ANTS: Section 6 : Types de documentsSection 7 : Identifiants (ID)Section 8 : ID dans chaque type de documents Ces informations permettent notamment de vérifier la validité d'un ID (taille, valeur ...), ou encore les DI obligatoires pour chaque document. Nous avons d'abord rassemblé ces données dans un tableur (depuis le fichier PDF). Ensuite, nous avons développé un script permettant de rassembler ces données dans un fichier JSON propre à chaque section. "},{"title":"🛠 Exemple pour la section S6:​","type":1,"pageTitle":"🏣 ANTS -> JSON","url":"docs/Implementation/Specifications/GDoc+GDoc->JSON#-exemple-pour-la-section-s6","content":"function subarray_push(array, i, j, value) { let al = array.length; for(var k=0;k<(i-al+1);k++){ array.push([]); } al = array[i].length; for(var k=0;k<(j-al+1);k++){ array[i].push([]); } array[i][j].push(value); } function s6() { var ss = SpreadsheetApp.getActiveSpreadsheet(); var sheet = ss.getSheetByName(\"Section 6\"); var range = sheet.getDataRange(); var values = range.getValues(); var data = {}; values.forEach((row, i) => { if(row[0] == '') return; data[row[1]] = { 'type': row[0], 'date_emission': row[2] == 'O' ? true : false, 'description': row[3] }; }) sheet.appendRow(['', 'JSON: ', JSON.stringify(data)]); } Copy info Le script complet ainsi que le tableur sont disponible en Annexe. "},{"title":"Structure des fichiers de specs​","type":1,"pageTitle":"🏣 ANTS -> JSON","url":"docs/Implementation/Specifications/GDoc+GDoc->JSON#structure-des-fichiers-de-specs","content":"Section6.json [ { \"type\": \"Justificatif de domicile\", \"code\": \"00\", \"date_emission\": true, \"description\": \"Document émis spécifiquement pour servir de justificatif de domicile.\" } ] Copy Section7.json [ { \"id\": \"01\", \"nom\": \"Identifiant unique du document.\", \"taille_min\": 0, \"taille_max\": -1, \"type\": \"Alphanumérique\", \"description\": \"Cet identifiant permet en fonction de l’émetteur (si celui-ci fournit le service) de récupérer le document correspondant. Cette donnée est encodée en utilisant uniquement des lettres majuscules non accentuées [A-Z] et des chiffres [0-9].\", \"conditions\": \"MAJ+CHIFFRES\" } ] Copy Section8.json { \"<S6>\": { \"obligatoire\": [\"<S7>\", \"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\"], \"facultatif\": [\"<S7>\", \"1K\",\"1J\",\"1I\",\"1G\"], \"conditions\": [ [ //A OU B [\"<S7>\", \"DK \", \"DL\"], [\"DM\", \"DN\", \"DO\", \"DP\"] ], [ // C OU D [\"DQ\", \"DR\",\"DS\"], [\"DT\"] ] ] } } Copy "},{"title":"💭 UML","type":0,"sectionRef":"#","url":"docs/project/UML","content":"💭 UML caution Rust n'étant pas un langage orienté objet, ceci n'est qu'un concept général !","keywords":""},{"title":"⚡ GitLab CI/CD","type":0,"sectionRef":"#","url":"docs/project/CI_CD","content":"","keywords":""},{"title":"📝 Explication​","type":1,"pageTitle":"⚡ GitLab CI/CD","url":"docs/project/CI_CD#-explication","content":"GitLab CI/CD est une fonctionnalité qui permet de mettre en place des pipelines de CI/CD pour n'importe quel projet, qu'il soit nouveau ou existant, pourvu qu'il utilise Git. Il nous permet d'automatiser les étapes : d'intégration continue : Build > Tests (unitaires, d'intégration, de non-régression...) de déploiement continu : Review > Déploiement (staging, production...) Cette automatisation accélère la production de code : un seul commit suffit à déclencher une pipeline côté GitLab qui s'occupera de générer un build de production, lancer la suite de tests et déployer la nouvelle version en staging/production ! Cela permet également d'augmenter la confiance des développeurs et la qualité du code envoyé en production, car on a l'assurance que chaque modification est passée par ce processus. "},{"title":"⚒ Pratique​","type":1,"pageTitle":"⚡ GitLab CI/CD","url":"docs/project/CI_CD#-pratique","content":"caution Gitlab ne garde qu'un seul site par projet. On utilise AWS pour sauvegarder tous les sites de toutes les branches stages: - build - test - deploy build_rust: stage: build image: rust:latest before_script: - apt update && apt -y install libdmtx-dev script: - echo \"Building library...\" - cargo build test_rust: stage: test image: rust:latest needs: - build_rust before_script: - apt update && apt -y install libdmtx-dev script: - echo \"Testing library...\" - cargo test #Build once for gitlab pages (to ../public). And a second time for live URL. pages: stage: build image: node:15.12-alpine3.13 script: - cd website - yarn install - yarn build - mv ./build ../public - >- sed -i -e \"s/baseUrl: '\\/lib2ddoc\\/',/baseUrl: '\\/$CI_COMMIT_SHORT_SHA\\/',/g\" docusaurus.config.js - >- sed -i -e \"s/url: 'https:\\/\\/pages.gitlab.io',/url: 'https:\\/\\/lib2ddoc.aws.ipv4.ovh',/g\" docusaurus.config.js - yarn build - mv ./build ../public2 artifacts: paths: - public - public2 deploy_website: stage: deploy needs: - pages image: registry.gitlab.com/gitlab-org/cloud-deploy/aws-base:latest script: - >- aws s3 sync public2/ \"s3://ovh.ipv4.aws.lib2ddoc/$CI_COMMIT_SHORT_SHA/\" Copy "},{"title":"🌍 Site Web","type":0,"sectionRef":"#","url":"docs/project/website","content":"","keywords":""},{"title":"🛠 Construction​","type":1,"pageTitle":"🌍 Site Web","url":"docs/project/website#-construction","content":"Docusaurus est un générateur de site web statique donc nous avons besoin de construire le site web dans un répertoire de contenu statique et de le mettre sur un serveur web pour qu'il puisse être consulté. Pour construire le site web : cd website npm run build Copy "},{"title":"🚀 Exécution​","type":1,"pageTitle":"🌍 Site Web","url":"docs/project/website#-exécution","content":"tip Docusaurus possède une fonctionalité de hot-reload ! cd website npm run start Copy "},{"title":"✏ Nouveau document​","type":1,"pageTitle":"🌍 Site Web","url":"docs/project/website#-nouveau-document","content":"Créez un fichier Markdown et placez-le dans le répertoire docs/: ├── docs │ └── hello-world.md ├── docusaurus.config.js ├── ... Copy De la même manière, une page sera créée à l'adresse http://localhost:3000/docs/hello. Maintenant, il faut ajouter le path du markdown créé dans le fichier sidebars.js et docusaurus.config.js "},{"title":"🔥 Démonstration","type":0,"sectionRef":"#","url":"docs/project/Demo","content":"","keywords":""},{"title":"Un passe sanitaire​","type":1,"pageTitle":"🔥 Démonstration","url":"docs/project/Demo#un-passe-sanitaire","content":"note Ce document est un document factice, dédié aux tests !  "},{"title":"Données​","type":1,"pageTitle":"🔥 Démonstration","url":"docs/project/Demo#données","content":"Texte:​ info C'est ce que contient le datamatrix (2d-doc) DC04FR0000011E581E58B201FRF0DEPOTHPRIM\u001dF1NEG\u001dF201011955F3FF4945006\u001dF5NF6070420211010\u001fMRZICP23SZTCLV2APC5P2AQVZDKHDKRG5KOIYGBKDXUA7N5O75QLWMKJBFSL3WJZYG2HHF4Z3K5E6E2GJFOVSV7E2W2XVHEXXVDXYNY JSON:​ info C'est ce que renvoie notre programme { \"is_ok\": true, \"headers\": { \"marqueur\": \"DC\", \"version\": 4, \"identifiant_de_ac\": \"FR00\", \"identifiant_du_certificat\": \"0001\", \"date_emission\": \"1E58\", \"date_signature\": \"1E58\", \"type_document\": \"B2\", \"type_document_description\": \"Test COVID\", \"perimetre\": \"01\", \"pays_emetteur\": \"FR\" }, \"message\": { \"F6\": { \"name\": \"Date et heure du prélèvement\", \"value\": \"070420211010\", \"is_valid\": true }, \"F3\": { \"name\": \"Genre\", \"value\": \"F\", \"is_valid\": true }, \"F4\": { \"name\": \"Code analyse\", \"value\": \"945006\", \"is_valid\": true }, \"F0\": { \"name\": \"Liste des prénoms\", \"value\": \"DEPOTHPRIM\", \"is_valid\": true }, \"F2\": { \"name\": \"Date de naissance\", \"value\": \"01011955\", \"is_valid\": true }, \"F5\": { \"name\": \"Résultat de l’analyse\", \"value\": \"N\", \"is_valid\": true }, \"F1\": { \"name\": \"Nom patronymique\", \"value\": \"NEG\", \"is_valid\": true } }, \"is_signature_valid\": true, \"annex\": \"\", \"is_document_valid\": true } Copy "},{"title":"🔓 Zone Annexe","type":0,"sectionRef":"#","url":"docs/Specifications/Annexe","content":"🔓 Zone Annexe Par besoin de faire varier certains éléments du code 2D-DOC, la version 04 intègre une zone annexe à la fin du code après la zone de signature. Le format de l’annexe est la même que la zone de message, cependant puisque celle-ci n’est pas prise en compte dans la signature ses informations ne peuvent pas être vérifiées. Ainsi il faut prendre des précautions avec ce message annexe car les données pourraient être frauduleuses. Un exemple d’utilité de l’annexe est dans le cas où le 2D-DOC contient les caractéristiques d’un produit et son numéro de série. On souhaite créer un 2D-DOC pour chaque produit mais cela est coûteux si l’on doit intégrer à chaque fois le numéro de série alors que les caractéristiques du produit restent les mêmes. Ainsi, en ajoutant le numéro de série dans l’annexe on peut le faire varier pour chaque élément produit. Pour insérer un bloc de données annexe en format C40 il faut insérer le séparateur <GS> à la fin de la signature mais pas en format binaire.","keywords":""},{"title":"🔑 Signature","type":0,"sectionRef":"#","url":"docs/Specifications/Signature","content":"🔑 Signature Cliquer ici pour être redirigé vers le module Sécurité","keywords":""},{"title":"⚓ Introduction","type":0,"sectionRef":"#","url":"docs/Specifications/Introduction","content":"⚓ Introduction Le but du 2D-DOC est de lutter contre la fraude documentaire. La fraude documentaire est un terme générique qui permet de désigner la falsification d'un document. Aujourd’hui, avec la crise de la Covid 19 les menaces liées aux fraudes se sont accentuées, cela dû au fait de la hausse du télétravail et l’utilisation des outils informatiques personnels. Pour lutter contre la fraude documentaire, le 2D-DOC doit atteindre cinq objectifs: Sécurité Interopérabilité Uniformité Facilité d'usage Durabilité Le 2D-DOC doit également permettre de simplifier et digitaliser les démarches administratives des usagers. Le premier objectif de sécurité implique que les données doivent être chiffrées. En effet, dans le 2D-DOC l’information est contenue dans un code à barres 2D (DataMatrix) qui emporte les informations clés du document, la date d’émission et la signature électronique de ces données. C’est l'émetteur qui réalise ce code à barres. Le code est sécurisé à l'aide d'une signature numérique fondée sur une cryptographie asymétrique. (clé publique/clé privée) qui permet le contrôle de la signature par tous les acteurs disposant de la clé publique du signataire émetteur. La vérification du code-barre se fait grâce à un scanner qui vérifie l’exactitude des données. note Ces précautions de cryptage permettent d’éviter les fuites d’informations qui peuvent être très coûteuses. Par exemple, la plus grande violation de sécurité a eu lieu en 2011 et a coûté à l'entreprise Epsilon plus de 4 milliard de dollars.","keywords":""},{"title":"🎩 En-tête","type":0,"sectionRef":"#","url":"docs/Specifications/Entete","content":"","keywords":""},{"title":"📄 Description​","type":1,"pageTitle":"🎩 En-tête","url":"docs/Specifications/Entete#-description","content":"Il y a différentes versions d'en-tête utilisées pour le dispositif 2D-DOC. L’en-tête contient les informations qui permettent de décoder et de vérifier les informations du 2D-DOC. La longueur de l’en-tête est de 22 bits pour les versions ‘01’, ‘02’, 24 bits pour la version ‘03’ et 26 bits pour la version ‘04’ car on ajoute des informations en plus dans les versions ‘03’ et ‘04’. L’en-tête contient tout ce qui est relié à l'identification du document. Ces informations permettent d’interpréter l’information contenu dans un 2D-DOC car elles fournissent le type de Code 2D-DOC, la version du code, les identifiants etc. Tout d’abord , on retrouve dans l'en-tête un marqueur d’identification du document. Celui-ci prend toujours la valeur DC. Ensuite on a la version du 2D-DOC (eg. 02) Puis on a l’Identifiant de l’Autorité de Certification ayant délivré le certificat utilisé par l’émetteur du document pour signer les Données. En fonction du format de codage, celui-ci peut être codé sur 4 caractères alphanumériques (format C40) ou sur 5 caractères hexadécimaux (format BINAIRE). Un exemple d’Identifiant de l’Autorité de Certification est Certigna FR03 (Service de sécurité informatique) ou Ariadnext FR04 (Entreprise de logiciels). Après, on a l’Identifiant du Certificat utilisé pour signer les données sur quatre caractères alphanumériques. Ainsi on récupère les certificats via des Annuaire de certificats qui suivent la norme RFC 4387. Ce certificat contient une clé publique qui est distribuée aux tierces parties intéressées par la vérification du code 2D-Doc. Ce certificat ne peut être stocké directement dans le 2D-DOC car il y aurait trop d’informations à coder dans le code à barres et celui-ci serait beaucoup trop grand. (eg. AB04) on a également la date d'émission et la date de signature du document codé en hexadécimal depuis le premier janvier 2000. Par exemple, la date du 29 avril 2021 correspond à 1E6D. Enfin, le code d’identification du type de document (détails) sur deux caractères alphanumériques. La version ‘03’ du 2D-DOC se différencie des versions précédentes par l’ajout d’un champ pour l’identifiant du périmètre sur lequel le type de document est défini. Pour l'instant, l'ensemble des documents est sous l’identifiant 01 (périmètre ANTS). La version ‘04’ du 2D-DOC on ajoute l’information Pays émetteur du document. Pour la France, cela correspond au code FR. note On obtient un code de la forme suivante pour l’en-tête des versions C40 ‘01’ et ‘02’ :DC02ANTSXT4A1E6D1E6D01 "},{"title":"⚒ Récapitulatif​","type":1,"pageTitle":"🎩 En-tête","url":"docs/Specifications/Entete#-récapitulatif","content":"En-tête d’un code 2D-Doc en C40 pour la version 04 :  "},{"title":"📒 Format général","type":0,"sectionRef":"#","url":"docs/Specifications/Format_2DDoc","content":"","keywords":""},{"title":"📝 Structure​","type":1,"pageTitle":"📒 Format général","url":"docs/Specifications/Format_2DDoc#-structure","content":"Un code 2D-Doc est constitué de plusieurs champs, deux champs principaux et un champ optionnel: la zone de données la signature des donnéeséventuellement des données annexes. La zone de données des données est composé lui-même de deux sous-zones: La zone d'en-tête contient les informations nécessaires pour décoder et vérifier le Code 2D-Doc. La zone de message contient les informations propres à chaque code 2D-Doc. Le message est représenté par une suite de couples (id,données). Le champ de la signature contient l'information qui nous permet de vérifier l'intégralité de nos données. Enfin, le champ de données annexe optionnelle a la même structure que la zone de message mais se trouve après la zone de signature. Puisque c’est un champ optionnel, son contenu n’est pas pris en compte dans la signature.  "},{"title":"⚒ Formats​","type":1,"pageTitle":"📒 Format général","url":"docs/Specifications/Format_2DDoc#-formats","content":"Plusieurs versions du 2D-DOC ont été mises à jour dès son début: "},{"title":"🔠 C40​","type":1,"pageTitle":"📒 Format général","url":"docs/Specifications/Format_2DDoc#-c40","content":"Le format C40 est utilisé pour encoder des données constituées essentiellement de caractères majuscules. Il transforme trois caractères alphanumériques en deux octets grâce à un tableau de caractères réduit à 40 caractères, encodés en base 40. L’avantage du format C40 c’est qu’il permet d’atteindre la capacité maximum alphanumérique en utilisant uniquement des chiffres, des espaces et des majuscules. C’est donc un codage optimisé qui limite également la taille des données. Un autre avantage du format C4O est qu’il est lisible sur différentes plateformes et interprétable par différents lecteurs à code barre. "},{"title":"🔢 Binaire​","type":1,"pageTitle":"📒 Format général","url":"docs/Specifications/Format_2DDoc#-binaire","content":"Le format binaire utilise un codage binaire c'est-à-dire le système de numérotation en base 2, il permet par exemple d'inclure de petites (images) dans les 2DDocs. Ci-dessus des exemples de format 2D-DOC. On remarque que les versions ‘01’ à ‘04’ contiennent un message C40, et la signature de la version ‘01’ est en binaire puis en C40 dans les versions ‘02’, ‘03’ et ‘04’. Enfin le quatrième bloc: l’annexe, est optionnel. "},{"title":"📨 Zone de Message","type":0,"sectionRef":"#","url":"docs/Specifications/Message","content":"","keywords":""},{"title":"🔠 Zone de message C40​","type":1,"pageTitle":"📨 Zone de Message","url":"docs/Specifications/Message#-zone-de-message-c40","content":"En C40, l’en-tête a une taille fixe de 26 caractères alphanumériques avant encodage. Un message est constitué d’une suite de blocs de données. Les blocs de données contiennent les éléments suivants: un identifiant de donnée ID codé sur deux caractèresla donnée elle-même encodée au format C40un caractère de fin de donnée appelé séparateur (<GS>) lorsqu’un bloc de données n’a pas une taille fixe Finalement, le caractère <RS> indique la fin de la zone de message  "},{"title":"🔢 Zone de message Binaire​","type":1,"pageTitle":"📨 Zone de Message","url":"docs/Specifications/Message#-zone-de-message-binaire","content":"L’identifiant de donnée (ID) est codé sur un octet (La valeur 0xFF n’est pas autorisée: elle est réservée pour indiquer le début de la signature) puis suivi d’un ou trois octets pour indiquer la taille de la donnée qui suit. Si la donnée est nulle alors l’octet prend la valeur de 0x00 "},{"title":"📚 Types de documents","type":0,"sectionRef":"#","url":"docs/Specifications/Types_de_documents","content":"📚 Types de documents Les différents types de documents au format C40 avec un exemple attribué par chacun: Type de document\tExemple\tID exempleJustificatif de domicile\tFactures de téléphonie\t01 Justificatif de domiciliation bancaire\tRelevé d’Identité bancaire\t03 Justificatif de ressources\tBulletin de salaire\t06 Justificatif d’identité\tDocument étranger\t13 Justificatif fiscal\tFacture étendue\t09 Justificatif d’emploi\tContrat de travail\t10 Justificatif de véhicule\tCertificat de qualité de l’air\tA0 Justificatif permis de conduire\tCourrier Permis à Points\tA1 Justificatif de santé\tCarte Mobilité Inclusion (CMI)\tA2 Justificatif d’activité\tPermis de chasser\tA9 Justificatif médical\tCertificat de décès\tA4 Justificatif académique\tDiplôme\tB0 Justificatif juridique/judiciaire\tActe d’huissier\t12 Certificat d’immatriculation\tCertificat de cession électronique\tA8 Autorisations douanières\tLicence d’exportation d’armes à feu\tC5 Résultats des tests virologiques\tTest COVID\tB2 Attestation Vaccinale\tAttestation Vaccinale\tL1 Justificatif d’Asile\tAttestation de Demande d’Asile\t16","keywords":""}]